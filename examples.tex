\section{Examples}

In this section, we will present several examples of how the final version of
our plug-in will work on pre-Java 8 code. Assume we have a \lstinline{List},
and suppose we wished to print each element of the list. In pre-Java 8,
we can use \lstinline{for (String s : list) System.out.println(s)} to do so.

One possible refactoring to use lambda expressions would be
\lstinline{list.forEach(s $\rightarrow$ System.out.println(s))}.
Here, we call the new \lstinline{forEach()} method on the list, passing the
lambda expression \lstinline{s $\rightarrow$ System.out.println(s)}, meaning that each
\lstinline{String} in the list (each of which gets bound to \lstinline{s}) is
passed to the \lstinline{println()} method. 

Another possible lambda expression refactoring would be
\lstinline{list.forEach(System.out::println)}. In this case, we again call the
\lstinline{forEach()} on the list but this time, instead of passing a lambda
expression, we pass a method reference, a new concept in Java 8 as well. Here,
we refer to the \lstinline{println()} method of the \lstinline{PrintStream}
class. When the lambda expression is processed, the \lstinline{println()}
method is called on the object referred to by the \lstinline{out} variable.

Yet, another possible refactoring is one where the new stream API, which
allows for parallel processing, would be
\lstinline{list.stream().forEach(System.out::println)}. This code sequentially
processes the list, while
\lstinline{list.parallelStream().forEach( System.out::println)} processes it in
parallel.
